{"version":3,"file":"viewer.js","sources":["../out/framecontainer/createIframe.js","../out/framecontainer/viewerParameters.js","../node_modules/@ampproject/viewer-messaging/messaging.js","../out/preprocessing/preprocessing-modules/Validator.js","../out/preprocessing/preprocess.js","../out/framecontainer/viewerConfig.js","../out/framecontainer/rendering-modules/ErrorHandler.js","../out/framecontainer/rendering-modules/IframeHeight.js","../out/framecontainer/rendering-modules/index.js","../out/framecontainer/FrameContainer.js","../out/preprocessing/preprocessing-modules/index.js"],"sourcesContent":["/**\n * Creates an iframe element with the provided options that includes sandbox\n * attributes, feature policy and styles.\n *\n * @param {!HTMLElement} parent Element to create an iframe inside of\n * @param {!IframeOptions} options Options used for the iframe\n * @return {!HTMLIFrameElement} Newly created iframe element\n */\nexport function createIframe(parent, options) {\n    const doc = parent.ownerDocument;\n    const iframe = doc.createElement('iframe');\n    if (options.width) {\n        iframe.setAttribute('width', options.width);\n    }\n    if (options.height) {\n        iframe.setAttribute('height', options.height);\n    }\n    iframe.setAttribute('allow', stringIfArray(options.featurePolicy, '; '));\n    iframe.setAttribute('loading', 'eager');\n    if (options.className) {\n        iframe.className = options.className;\n    }\n    if (options.styles) {\n        iframe.style.cssText = stringIfArray(options.styles, '; ');\n    }\n    if (options.sandbox) {\n        iframe.setAttribute('sandbox', stringIfArray(options.sandbox, ' '));\n    }\n    if (options.src) {\n        iframe.src = options.src || '';\n    }\n    if (options.srcdoc) {\n        iframe.setAttribute('srcdoc', options.srcdoc);\n    }\n    if (options.name) {\n        iframe.name = options.name;\n    }\n    parent.prepend(iframe);\n    return iframe;\n}\nfunction stringIfArray(input, joiner) {\n    if (!input) {\n        return '';\n    }\n    if (Array.isArray(input)) {\n        return input.join(joiner);\n    }\n    return input;\n}\n//# sourceMappingURL=createIframe.js.map","/**\n * AMP Viewer capabilities that can be specified in the `cap` parameter.\n *\n * @see {@link https://github.com/ampproject/amphtml/blob/master/extensions/amp-viewer-integration/CAPABILITIES.md}\n */\nexport var ViewerCapability;\n(function (ViewerCapability) {\n    ViewerCapability[\"A2A\"] = \"a2a\";\n    ViewerCapability[\"CLIENT_ID_SERVICE\"] = \"cid\";\n    ViewerCapability[\"ERROR_REPORTER\"] = \"errorReporter\";\n    ViewerCapability[\"FRAGMENT\"] = \"fragment\";\n    ViewerCapability[\"HANDSHAKEPOLL\"] = \"handshakepoll\";\n    ViewerCapability[\"NAVIGATE_TO\"] = \"navigateTo\";\n    ViewerCapability[\"REPLACE_URL\"] = \"replaceUrl\";\n    ViewerCapability[\"SWIPE\"] = \"swipe\";\n    ViewerCapability[\"VIEWER_RENDER_TEMPLATE\"] = \"viewerRenderTemplate\";\n    ViewerCapability[\"XHR_INTERCEPTOR\"] = \"xhrInterceptor\";\n})(ViewerCapability || (ViewerCapability = {}));\n/**\n * AMP Viewer viewport types that can be specified in the `viewportType`\n * parameter.\n */\nexport var ViewerViewportType;\n(function (ViewerViewportType) {\n    ViewerViewportType[\"NATURAL\"] = \"natural\";\n    ViewerViewportType[\"NATURAL_IOS_EMBED\"] = \"natural-ios-embed\";\n})(ViewerViewportType || (ViewerViewportType = {}));\n/**\n * AMP Viewer visibility states that can be specified in the `visibilityState`\n * parameter.\n */\nexport var ViewerVisibilityState;\n(function (ViewerVisibilityState) {\n    ViewerVisibilityState[\"INACTIVE\"] = \"inactive\";\n    ViewerVisibilityState[\"PAUSED\"] = \"paused\";\n    ViewerVisibilityState[\"VISIBLE\"] = \"visible\";\n    ViewerVisibilityState[\"PRERENDER\"] = \"prerender\";\n    ViewerVisibilityState[\"HIDDEN\"] = \"hidden\";\n})(ViewerVisibilityState || (ViewerVisibilityState = {}));\n/**\n * AMP Viewer parameters are provided as a query string that follows a fragment\n * identifier (#). For example, https://amp.example/page.html#foo=1&bar=2\n *\n * This function appends the given parameters in the correct format to an\n * existing URL.\n *\n * @param {string} url URL to append parameters to\n * @param {ViewerParameters=} parameters Viewer parameters to append\n * @return {string} URL with appended parameters\n */\nexport function appendParametersToURL(url, parameters) {\n    if (!parameters) {\n        return url;\n    }\n    return url + '#' + parametersToString(parameters);\n}\nexport function parametersToString(parameters) {\n    const output = [];\n    for (const key of Object.keys(parameters)) {\n        // cast to 'any' to allow [] access\n        // tslint:disable:no-any\n        let value = parameters[key];\n        if (typeof value === 'undefined') {\n            continue;\n        }\n        if (typeof value === 'boolean') {\n            value = value ? 1 : 0;\n        }\n        output.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n    return output.join('&');\n}\n//# sourceMappingURL=viewerParameters.js.map","/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst TAG = 'amp-viewer-messaging';\nconst CHANNEL_OPEN_MSG = 'channelOpen';\nconst HANDSHAKE_POLL_MSG = 'handshake-poll';\nconst APP = '__AMPHTML__';\n\n/**\n * @enum {string}\n */\nconst MessageType = {\n  REQUEST: 'q',\n  RESPONSE: 's',\n};\n\n/**\n * @typedef {function(string, *, boolean):(!Promise<*>|undefined)}\n */\nlet RequestHandler; // eslint-disable-line no-unused-vars\n\n/**\n * @param {*} message\n * @return {?AmpViewerMessage}\n */\nexport function parseMessage(message) {\n  if (typeof message != 'string') {\n    return /** @type {AmpViewerMessage} */ (message);\n  }\n  if (message.charAt(0) != '{') {\n    return null;\n  }\n\n  try {\n    return /** @type {?AmpViewerMessage} */ (JSON.parse(\n      /** @type {string} */ (message)\n    ));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * @fileoverview This class is a de-facto implementation of MessagePort\n * from Channel Messaging API:\n * https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API\n */\nexport class WindowPortEmulator {\n  /**\n   * @param {!Window} win\n   * @param {string} origin\n   * @param {!Window} target\n   */\n  constructor(win, origin, target) {\n    /** @const @private {!Window} */\n    this.win_ = win;\n    /** @const @private {string} */\n    this.origin_ = origin;\n    /** @const @private {!Window} */\n    this.target_ = target;\n  }\n\n  /**\n   * @param {string} eventType\n   * @param {function(!Event):*} handler\n   */\n  addEventListener(eventType, handler) {\n    this.win_.addEventListener('message', event => {\n      if (event.origin == this.origin_ && event.source == this.target_) {\n        handler(event);\n      }\n    });\n  }\n\n  /**\n   * @param {JsonObject} data\n   */\n  postMessage(data) {\n    // Opaque (null) origin can only receive messages sent to \"*\"\n    const targetOrigin = this.origin_ === 'null' ? '*' : this.origin_;\n\n    this.target_./*OK*/ postMessage(data, targetOrigin);\n  }\n\n  /**\n   * Starts the sending of messages queued on the port.\n   */\n  start() {}\n}\n\n/**\n * @fileoverview This is used in amp-viewer-integration.js for the\n * communication protocol between AMP and the viewer. In the comments, I will\n * refer to the communication as a conversation between me and Bob. The\n * messaging protocol should support both sides, but at this point I'm the\n * ampdoc and Bob is the viewer.\n */\nexport class Messaging {\n  /**\n   * Performs a handshake and initializes messaging.\n   *\n   * Requires the `handshakepoll` viewer capability and the `origin` viewer parameter to be specified.\n   * @param {!Window} target - window containing AMP document to perform handshake with\n   * @param {?string=} opt_token - message token to verify on incoming messages (must be provided as viewer parameter)\n   * @return {!Promise<!Messaging>}\n   */\n  static initiateHandshakeWithDocument(target, opt_token) {\n    return new Promise(resolve => {\n      const intervalRef = setInterval(() => {\n        let channel;\n        try {\n          channel = new MessageChannel();\n        } catch (err) {\n          console.log(err, 'err');\n        }\n        const pollMessage = /** @type {JsonObject} */ ({\n          app: APP,\n          name: HANDSHAKE_POLL_MSG,\n        });\n        target./*OK*/ postMessage(pollMessage, '*', [channel.port2]);\n\n        const port = channel.port1;\n        const listener = event => {\n          const message = parseMessage(event.data);\n          if (!message) {\n            return;\n          }\n          if (message.app === APP && message.name === CHANNEL_OPEN_MSG) {\n            clearInterval(intervalRef);\n            port.removeEventListener('message', listener);\n            const messaging = new Messaging(\n              null,\n              port,\n              /* opt_isWebview */ false,\n              opt_token,\n              /* opt_verifyToken */ true\n            );\n            messaging.sendResponse_(message.requestid, CHANNEL_OPEN_MSG, null);\n            resolve(messaging);\n          }\n        };\n        port.addEventListener('message', listener);\n        port.start();\n      }, 1000);\n    });\n  }\n\n  /**\n   * Waits for handshake from iframe and initializes messaging.\n   *\n   * Requires the `origin` viewer parameter to be specified.\n   * @param {!Window} source - the source window containing the viewer\n   * @param {!Window} target - window containing AMP document to perform handshake with (usually contentWindow of iframe)\n   * @param {string} origin - origin of target window (use \"null\" if opaque)\n   * @param {?string=} opt_token - message token to verify on incoming messages (must be provided as viewer parameter)\n   * @return {!Promise<!Messaging>}\n   */\n  static waitForHandshakeFromDocument(source, target, origin, opt_token) {\n    return new Promise(resolve => {\n      debugger;\n      const listener = event => {\n        debugger;\n        const message = parseMessage(event.data);\n        if (!message) {\n          return;\n        }\n        if (\n          event.origin == origin &&\n          (!event.source || event.source == target) &&\n          message.app === APP &&\n          message.name === CHANNEL_OPEN_MSG\n        ) {\n          source.removeEventListener('message', listener);\n          const port = new WindowPortEmulator(source, origin, target);\n          const messaging = new Messaging(\n            null,\n            port,\n            /* opt_isWebview */ false,\n            opt_token,\n            /* opt_verifyToken */ true\n          );\n          messaging.sendResponse_(message.requestid, CHANNEL_OPEN_MSG, null);\n          resolve(messaging);\n        }\n      };\n      source.addEventListener('message', listener);\n    });\n  }\n\n  /**\n   * Conversation (messaging protocol) between me and Bob.\n   * @param {?Window} win\n   * @param {!MessagePort|!WindowPortEmulator} port\n   * @param {boolean=} opt_isWebview\n   * @param {?string=} opt_token\n   * @param {boolean=} opt_verifyToken\n   */\n  constructor(win, port, opt_isWebview, opt_token, opt_verifyToken) {\n    /** @const @private {?Window} */\n    this.win_ = win;\n    /** @const @private {!MessagePort|!WindowPortEmulator} */\n    this.port_ = port;\n    /** @const @private */\n    this.isWebview_ = !!opt_isWebview;\n\n    /**\n     * A token that the viewer may include as an init parameter to enhance\n     * security for communication to opaque origin (a.k.a. null origin) AMP\n     * documents.\n     *\n     * For an AMP document embedded inside a sandbox iframe, the origin of the\n     * document would be \"null\", which defeats the purpose of an origin check.\n     * An attacker could simply create a sandboxed, malicious iframe (therefore\n     * having null origin), walk on the DOM frame tree to find a reference to\n     * the viewer iframe (this is not constrained by the same origin policy),\n     * and then send postMessage() calls to the viewer frame and pass the\n     * viewer's origin checks, if any.\n     *\n     * The viewer could also check the source of the message to be a legitimate\n     * AMP iframe window, but the attacker could bypass that by navigating the\n     * legitimate AMP iframe window away to a malicious document. Recent\n     * browsers have banned this kind of attack, but it's tricky to rely on it.\n     *\n     * To prevent the above attack in a null origin AMP document, the viewer\n     * should include this token in an init parameter, either in the `src` or\n     * `name` attribute of the iframe, and then verify that this token is\n     * included in all the messages sent from AMP to the viewer. The attacker\n     * would not be able to steal this token under the same origin policy,\n     * because the token is inside the viewer document at a different origin\n     * and the attacker can't access it.\n     * @const @private {?string}\n     */\n    this.token_ = opt_token || null;\n\n    /**\n     * If true, the token above is verified on incoming messages instead of\n     * being attached to outgoing messages.\n     * @const @private {boolean}\n     */\n    this.verifyToken_ = !!opt_verifyToken;\n\n    /** @private {number} */\n    this.requestIdCounter_ = 0;\n    /** @private {!Object<number, {resolve: function(*), reject: function(!Error)}>} */\n    this.waitingForResponse_ = {};\n    /**\n     * A map from message names to request handlers.\n     * @private {!Object<string, !RequestHandler>}\n     */\n    this.messageHandlers_ = {};\n\n    /** @private {?RequestHandler} */\n    this.defaultHandler_ = null;\n\n    this.port_.addEventListener('message', this.handleMessage_.bind(this));\n    this.port_.start();\n  }\n\n  /**\n   * Registers a method that will handle requests sent to the specified\n   * message name.\n   * @param {string} messageName The name of the message to handle.\n   * @param {!RequestHandler} requestHandler\n   */\n  registerHandler(messageName, requestHandler) {\n    this.messageHandlers_[messageName] = requestHandler;\n  }\n\n  /**\n   * Unregisters the handler for the specified message name.\n   * @param {string} messageName The name of the message to unregister.\n   */\n  unregisterHandler(messageName) {\n    delete this.messageHandlers_[messageName];\n  }\n\n  /**\n   * @param {?RequestHandler} requestHandler\n   */\n  setDefaultHandler(requestHandler) {\n    this.defaultHandler_ = requestHandler;\n  }\n\n  /**\n   * Bob sent me a message. I need to decide if it's a new request or\n   * a response to a previous 'conversation' we were having.\n   * @param {!Event} event\n   * @private\n   */\n  handleMessage_(event) {\n    const message = parseMessage(event.data);\n    if (!message || message.app !== APP) {\n      return;\n    }\n    if (\n      this.token_ &&\n      this.verifyToken_ &&\n      message.messagingToken !== this.token_\n    ) {\n      // We received a message with an invalid token - dismiss it.\n      this.logError_(TAG + ': handleMessage_ error: ', 'invalid token');\n      return;\n    }\n    if (message.type === MessageType.REQUEST) {\n      this.handleRequest_(message);\n    } else if (message.type === MessageType.RESPONSE) {\n      this.handleResponse_(message);\n    }\n  }\n\n  /**\n   * I'm sending Bob a new outgoing request.\n   * @param {string} messageName\n   * @param {?JsonObject|string|undefined} messageData\n   * @param {boolean} awaitResponse\n   * @return {!Promise<*>|undefined}\n   */\n  sendRequest(messageName, messageData, awaitResponse) {\n    const requestId = ++this.requestIdCounter_;\n    let promise = undefined;\n    if (awaitResponse) {\n      promise = new Promise((resolve, reject) => {\n        this.waitingForResponse_[requestId] = {resolve, reject};\n      });\n    }\n    this.sendMessage_(\n      /** @type {!AmpViewerMessage} */ ({\n        app: APP,\n        requestid: requestId,\n        type: MessageType.REQUEST,\n        name: messageName,\n        data: messageData,\n        rsvp: awaitResponse,\n      })\n    );\n    return promise;\n  }\n\n  /**\n   * I'm responding to a request that Bob made earlier.\n   * @param {number} requestId\n   * @param {string} messageName\n   * @param {*} messageData\n   * @private\n   */\n  sendResponse_(requestId, messageName, messageData) {\n    this.sendMessage_(\n      /** @type {!AmpViewerMessage} */ ({\n        app: APP,\n        requestid: requestId,\n        type: MessageType.RESPONSE,\n        name: messageName,\n        data: messageData,\n      })\n    );\n  }\n\n  /**\n   * @param {number} requestId\n   * @param {string} messageName\n   * @param {*} reason !Error most of time, string sometimes, * rarely.\n   * @private\n   */\n  sendResponseError_(requestId, messageName, reason) {\n    const errString = this.errorToString_(reason);\n    this.logError_(\n      TAG + ': sendResponseError_, message name: ' + messageName,\n      errString\n    );\n    this.sendMessage_(\n      /** @type {!AmpViewerMessage} */ ({\n        app: APP,\n        requestid: requestId,\n        type: MessageType.RESPONSE,\n        name: messageName,\n        data: null,\n        error: errString,\n      })\n    );\n  }\n\n  /**\n   * @param {!AmpViewerMessage} message\n   * @private\n   */\n  sendMessage_(message) {\n    const /** Object<string, *> */ finalMessage = Object.assign(message, {});\n    if (this.token_ && !this.verifyToken_) {\n      finalMessage.messagingToken = this.token_;\n    }\n    this.port_./*OK*/ postMessage(\n      this.isWebview_\n        ? JSON.stringify(/** @type {!JsonObject} */ (finalMessage))\n        : finalMessage\n    );\n  }\n\n  /**\n   * I'm handling an incoming request from Bob. I'll either respond normally\n   * (ex: \"got it Bob!\") or with an error (ex: \"I didn't get a word of what\n   * you said!\").\n   * @param {!AmpViewerMessage} message\n   * @private\n   */\n  handleRequest_(message) {\n    let handler = this.messageHandlers_[message.name];\n    if (!handler) {\n      handler = this.defaultHandler_;\n    }\n    if (!handler) {\n      const error = new Error(\n        'Cannot handle request because no default handler is set!'\n      );\n      error.args = message.name;\n      throw error;\n    }\n\n    const promise = handler(message.name, message.data, !!message.rsvp);\n    if (message.rsvp) {\n      const requestId = message.requestid;\n      if (!promise) {\n        this.sendResponseError_(\n          requestId,\n          message.name,\n          new Error('no response')\n        );\n        throw new Error('expected response but none given: ' + message.name);\n      }\n      promise.then(\n        data => {\n          this.sendResponse_(requestId, message.name, data);\n        },\n        reason => {\n          this.sendResponseError_(requestId, message.name, reason);\n        }\n      );\n    }\n  }\n\n  /**\n   * I sent out a request to Bob. He responded. And now I'm handling that\n   * response.\n   * @param {!AmpViewerMessage} message\n   * @private\n   */\n  handleResponse_(message) {\n    const requestId = message.requestid;\n    const pending = this.waitingForResponse_[requestId];\n    if (pending) {\n      delete this.waitingForResponse_[requestId];\n      if (message.error) {\n        this.logError_(TAG + ': handleResponse_ error: ', message.error);\n        pending.reject(\n          new Error(`Request ${message.name} failed: ${message.error}`)\n        );\n      } else {\n        pending.resolve(message.data);\n      }\n    }\n  }\n\n  /**\n   * @param {string} state\n   * @param {!Error|string=} opt_data\n   * @private\n   */\n  logError_(state, opt_data) {\n    if (!this.win_) {\n      return;\n    }\n    let stateStr = 'amp-messaging-error-logger: ' + state;\n    const dataStr = ' data: ' + this.errorToString_(opt_data);\n    stateStr += dataStr;\n    this.win_['viewerState'] = stateStr;\n  }\n\n  /**\n   * @param {*} err !Error most of time, string sometimes, * rarely.\n   * @return {string}\n   * @private\n   */\n  errorToString_(err) {\n    return err ? (err.message ? err.message : String(err)) : 'unknown error';\n  }\n}\n","const FORMAT = 'AMP4EMAIL';\nconst VALIDATOR_JS = 'https://cdn.ampproject.org/v0/validator.js';\n/**\n * Throws if the given code is not valid AMP.\n *\n * @param {string} amp AMP code to validate\n * @param {!Config} config Global config\n * @return {!Promise<string>} Validated AMP code\n */\nasync function process(amp, config) {\n    const validator = await loadValidator();\n    const result = validator.validateString(amp, FORMAT);\n    if (result.status !== 'PASS') {\n        // TODO: add errors inside this object\n        throw new Error('AMP validation failed');\n    }\n    return amp;\n}\n/**\n * Downloads and loads validator.js if it's not already loaded.\n *\n * @return {!Promise<Validator>} Validator object\n */\nfunction loadValidator() {\n    return new Promise(resolve => {\n        if (window.amp && window.amp.validator) {\n            resolve(window.amp.validator);\n            return;\n        }\n        let script = findValidatorJS();\n        if (!script) {\n            script = document.createElement('script');\n            script.src = VALIDATOR_JS;\n            document.body.appendChild(script);\n        }\n        script.addEventListener('load', () => resolve(window.amp.validator));\n    });\n}\n/**\n * Finds an existing script tag with validator.js.\n *\n * @return {?HTMLScriptElement} Script element\n */\nfunction findValidatorJS() {\n    const scripts = Array.from(document.getElementsByTagName('script'));\n    return scripts.find(({ src }) => src === VALIDATOR_JS);\n}\nexport const module = {\n    name: 'Validator',\n    process,\n};\n//# sourceMappingURL=Validator.js.map","import { modules as preprocessingModules } from './preprocessing-modules/index';\n/**\n * Runs the preprocessing modules on the given AMP code.\n *\n * @param {string} amp AMP code to preprocess\n * @param {!Config} config Global config\n * @param {Array<string>=} modules Module whitelist (leave empty to run all)\n * @return {!Promise<string>} Preprocessed AMP code\n */\nexport async function preprocessAMP(amp, config) {\n    const skipSet = new Set(config.skipPreprocessingModules || []);\n    for (const module of preprocessingModules) {\n        if (skipSet.has(module.name)) {\n            continue;\n        }\n        amp = await module.process(amp, config);\n    }\n    return amp;\n}\n//# sourceMappingURL=preprocess.js.map","import { ViewerCapability, ViewerVisibilityState, } from './viewerParameters';\n/**\n * Feature-Policy of the iframe that displays an AMP page.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy}\n */\nexport const IFRAME_FEATURE_POLICY = [\n    \"autoplay 'none'\",\n    \"camera 'none'\",\n    \"encrypted-media 'none'\",\n    \"fullscreen 'none'\",\n    \"geolocation 'none'\",\n    \"gyroscope 'none'\",\n    \"magnetometer 'none'\",\n    \"microphone 'none'\",\n    \"midi 'none'\",\n    \"payment 'none'\",\n    \"speaker 'none'\",\n    \"sync-xhr 'none'\",\n    \"vr 'none'\",\n];\n/**\n * Default sandbox attributes of the iframe that displays an AMP page.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}\n */\nexport const IFRAME_SANDBOX = [\n    'allow-scripts',\n    'allow-forms',\n    'allow-popups',\n    'allow-popups-to-escape-sandbox',\n];\n/**\n * Default styles applied to the iframe that displays an AMP page.\n */\nexport const IFRAME_STYLES = ['border: none', 'overflow: hidden'];\n/**\n * Default viewer parameters used for the AMP viewer.\n */\nexport const VIEWER_PARAMETERS = {\n    prerenderSize: 0,\n    visibilityState: ViewerVisibilityState.VISIBLE,\n    paddingTop: 0,\n    history: true,\n    p2r: false,\n    horizontalScrolling: false,\n    storage: true,\n    development: false,\n    log: false,\n    csi: true,\n    cap: [\n        ViewerCapability.XHR_INTERCEPTOR,\n        ViewerCapability.ERROR_REPORTER,\n    ],\n};\n/**\n * Rendering modules used by default.\n */\nexport const DEFAULT_RENDERING_MODULES = ['IframeHeight', 'ErrorHandler'];\n//# sourceMappingURL=viewerConfig.js.map","/**\n * Reacts to errors received from the AMP document and cancels loading if an\n * unexpected error happens in a short period after the document loads.\n */\nclass ErrorHandlerImpl {\n    constructor(frameContainer) {\n        this.loadErrorRejector = null;\n        this.errorHandler = (name, data, rsvp) => {\n            if (this.loadErrorRejector &&\n                data.a === ErrorType.Developer &&\n                data.ex === ErrorExpectancy.Unexpected) {\n                this.loadErrorRejector(data);\n            }\n            return Promise.resolve();\n        };\n        this.frameContainer = frameContainer;\n        this.messaging = frameContainer.getMessaging();\n        this.config = frameContainer.getConfig();\n    }\n    start() {\n        this.messaging.registerHandler('error', this.errorHandler);\n    }\n    async checkForLoadErrors() {\n        try {\n            await new Promise((resolve, reject) => {\n                this.loadErrorRejector = reject;\n                setTimeout(() => resolve, this.config.failOnLoadErrorAfter);\n            });\n        }\n        catch (error) {\n            this.frameContainer.reportError(error.m);\n        }\n        this.loadErrorRejector = null;\n    }\n    documentLoaded() {\n        if (!this.config.failOnLoadErrorAfter) {\n            return;\n        }\n        this.checkForLoadErrors();\n    }\n    documentUnloaded() { }\n}\nvar ErrorType;\n(function (ErrorType) {\n    ErrorType[\"Developer\"] = \"0\";\n    ErrorType[\"User\"] = \"1\";\n})(ErrorType || (ErrorType = {}));\nvar ErrorExpectancy;\n(function (ErrorExpectancy) {\n    ErrorExpectancy[\"Unexpected\"] = \"0\";\n    ErrorExpectancy[\"Expected\"] = \"1\";\n})(ErrorExpectancy || (ErrorExpectancy = {}));\nfunction load(frameContainer) {\n    const impl = new ErrorHandlerImpl(frameContainer);\n    impl.start();\n    return impl;\n}\nexport const module = {\n    name: 'ErrorHandler',\n    load,\n};\n//# sourceMappingURL=ErrorHandler.js.map","/**\n * Reacts to changes to the AMP document's height and resizes the iframe to\n * adjust to them.\n */\nclass IframeHeightImpl {\n    constructor(frameContainer) {\n        this.documentHeightHandler = (name, data, rsvp) => {\n            this.iframe.setAttribute('height', String(data.height));\n            return Promise.resolve();\n        };\n        this.iframe = frameContainer.getIframe();\n        this.messaging = frameContainer.getMessaging();\n    }\n    start() {\n        this.messaging.registerHandler('documentHeight', this.documentHeightHandler);\n    }\n    documentLoaded() { }\n    documentUnloaded() { }\n}\nfunction load(frameContainer) {\n    const impl = new IframeHeightImpl(frameContainer);\n    impl.start();\n    return impl;\n}\nexport const module = {\n    name: 'IframeHeight',\n    load,\n};\n//# sourceMappingURL=IframeHeight.js.map","import { module as IframeHeight } from './IframeHeight';\nimport { module as ErrorHandler } from './ErrorHandler';\nexport const modules = [IframeHeight, ErrorHandler];\n//# sourceMappingURL=index.js.map","import { createIframe } from './createIframe';\nimport { appendParametersToURL, parametersToString } from './viewerParameters';\nimport * as viewerConfig from './viewerConfig';\nimport { Messaging } from '@ampproject/viewer-messaging';\nimport { modules as renderingModules, } from './rendering-modules/index';\n/**\n * Creates an iframe that can render an AMP document, connects it with viewer\n * messaging and loads the rendering modules.\n */\nexport class FrameContainer {\n    /**\n     * @param {!HTMLElement} parent Element to create an iframe inside of\n     * @param {!Config} config Config with parameters related to the AMP viewer\n     */\n    constructor(parent, config) {\n        this.iframe = null;\n        this.messaging = null;\n        this.renderingModules = [];\n        this.documentLoadResolver = null;\n        this.messageHandlers = {};\n        this.messageHandler = (name, data, rsvp) => {\n            if (this.config.verboseMessages) {\n                console.log(`Received message: ${name} ${JSON.stringify(data)}`);\n            }\n            return Promise.resolve();\n        };\n        this.documentLoaded = (name, data, rsvp) => {\n            if (this.documentLoadResolver) {\n                this.documentLoadResolver();\n                this.documentLoadResolver = null;\n            }\n            for (const module of this.renderingModules) {\n                module.documentLoaded();\n            }\n            return Promise.resolve();\n        };\n        this.parent = parent;\n        this.config = config;\n        this.targetOrigin = this.getTargetOrigin();\n        this.messagingToken = this.generateMessagingToken();\n        this.enabledRenderingModules = new Set(viewerConfig.DEFAULT_RENDERING_MODULES);\n    }\n    /**\n     * Renders the provided AMP code inside the frame container.\n     *\n     * @param {string} amp AMP code to display\n     * @param {object} options\n     * @return {!Promise} Resolves when rendered\n     */\n    async render(amp, options) {\n        if (this.iframe) {\n            this.parent.removeChild(this.iframe);\n            this.iframe = null;\n            this.unloadDocument();\n        }\n        this.createViewerIframe(amp);\n        if (!this.config.useSrcDoc) {\n            await this.injectAMP(amp);\n        }\n        this.startLoadingTimer(options.onRenderSuccess, options.onRenderError);\n        await this.startMessaging();\n        this.setIframeConnected();\n    }\n    async reinitialize() {\n        this.iframe = this.parent.querySelector('iframe');\n        if (!this.iframe || this.isIframeConnected()) {\n            return;\n        }\n        await this.startMessaging();\n        this.setIframeConnected();\n    }\n    setIframeConnected() {\n        this.iframe?.setAttribute('data-connected', 'true');\n    }\n    isIframeConnected() {\n        return Boolean(this.iframe?.dataset.connected);\n    }\n    /**\n     * Unloads the AMP document and displays an error in its place.\n     *\n     * @param {string=} error Information about the error\n     */\n    reportError(error) {\n        if (!this.iframe) {\n            return;\n        }\n        this.unloadDocument();\n        let message = 'Error loading AMP page.';\n        if (error) {\n            message += '\\n' + error;\n        }\n        this.iframe.src = 'data:text/plain;base64,' + btoa(message);\n        this.iframe.setAttribute('height', '50');\n    }\n    /**\n     * Returns the iframe element that contains an AMP page.\n     *\n     * @return {!HTMLIFrameElement}\n     */\n    getIframe() {\n        if (!this.iframe) {\n            throw new Error('iframe not initialized yet');\n        }\n        return this.iframe;\n    }\n    /**\n     * Returns the Messaging object used to communicate with the AMP page.\n     *\n     * @return {!Messaging}\n     */\n    getMessaging() {\n        if (!this.messaging) {\n            throw new Error('Messaging not initialized yet');\n        }\n        return this.messaging;\n    }\n    /**\n     * Returns the Config.\n     *\n     * @return {!Config}\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Enables the given rendering module. Must be called before render.\n     *\n     * @param {string} module Name of module to enable\n     */\n    enableRenderingModule(module) {\n        this.enabledRenderingModules.add(module);\n    }\n    /**\n     * Disables the given rendering module. Must be called before render.\n     *\n     * @param {string} module Name of module to disable\n     */\n    disableRenderingModule(module) {\n        this.enabledRenderingModules.delete(module);\n    }\n    registerMessageHandler(messageName, handler) {\n        this.messageHandlers[messageName] = handler;\n    }\n    unloadDocument() {\n        this.messaging = null;\n        for (const module of this.renderingModules) {\n            module.documentUnloaded();\n        }\n        this.renderingModules = [];\n    }\n    createViewerIframe(amp) {\n        const iframeOptions = {\n            width: '100%',\n            height: '1',\n            featurePolicy: viewerConfig.IFRAME_FEATURE_POLICY,\n            sandbox: this.getIframeSandbox(),\n            styles: viewerConfig.IFRAME_STYLES,\n        };\n        if (this.config.useSrcDoc) {\n            iframeOptions.srcdoc = amp;\n            iframeOptions.name = this.getIframeName();\n        }\n        else {\n            iframeOptions.src = this.getIframeSrc();\n        }\n        this.iframe = createIframe(this.parent, iframeOptions);\n    }\n    async waitForIframeLoad() {\n        return new Promise(resolve => {\n            this.iframe.addEventListener('load', () => resolve());\n        });\n    }\n    async injectAMP(amp) {\n        await this.waitForIframeLoad();\n        this.iframe.contentWindow.postMessage({ amp }, '*');\n    }\n    async startLoadingTimer(onRenderSuccess, onRenderError) {\n        try {\n            await new Promise((resolve, reject) => {\n                this.documentLoadResolver = resolve;\n                if (this.config.loadTimeout) {\n                    setTimeout(() => reject(), this.config.loadTimeout);\n                }\n            });\n            if (onRenderSuccess) {\n                onRenderSuccess();\n            }\n        }\n        catch (e) {\n            if (onRenderError) {\n                onRenderError(e);\n            }\n            this.reportError('Loading timeout');\n        }\n    }\n    async startMessaging() {\n        const target = this.iframe.contentWindow;\n        const messaging = await Messaging.waitForHandshakeFromDocument(window, target, this.targetOrigin, this.messagingToken);\n        this.messaging = messaging;\n        this.messaging.setDefaultHandler(this.messageHandler);\n        this.messaging.registerHandler('documentLoaded', this.documentLoaded);\n        Object.keys(this.messageHandlers).forEach((messageName) => {\n            this.messaging?.registerHandler(messageName, this.messageHandlers[messageName]);\n        });\n        this.loadRenderingModules();\n        this.messaging.sendRequest('visibilitychange', {}, true);\n    }\n    loadRenderingModules() {\n        for (const module of renderingModules) {\n            if (this.enabledRenderingModules.has(module.name)) {\n                this.renderingModules.push(module.load(this));\n            }\n        }\n    }\n    getIframeSandbox() {\n        if (this.config.useOpaqueOrigin) {\n            return viewerConfig.IFRAME_SANDBOX;\n        }\n        return viewerConfig.IFRAME_SANDBOX.concat('allow-same-origin');\n    }\n    getIframeSrc() {\n        return appendParametersToURL(this.config.relayPageURL, this.getIframeParameters());\n    }\n    getIframeParameters() {\n        return Object.assign({\n            origin: window.location.origin,\n            messagingToken: this.messagingToken,\n        }, viewerConfig.VIEWER_PARAMETERS);\n    }\n    getIframeName() {\n        return '__AMP__' + parametersToString(this.getIframeParameters());\n    }\n    generateMessagingToken() {\n        const bytes = new Uint8Array(32);\n        window.crypto.getRandomValues(bytes);\n        const bytesStr = String.fromCharCode.apply(null, Array.from(bytes));\n        return btoa(bytesStr);\n    }\n    getTargetOrigin() {\n        if (this.config.useOpaqueOrigin) {\n            return 'null';\n        }\n        return new URL(this.config.relayPageURL).origin;\n    }\n}\n//# sourceMappingURL=FrameContainer.js.map","import { module as Validator } from './Validator';\nexport const modules = [Validator];\n//# sourceMappingURL=index.js.map"],"names":["stringIfArray","input","joiner","Array","parametersToString","parameters","output","Object","key","value","encodeURIComponent","parseMessage","message","e","_callee","amp","config","loadValidator","validator","FORMAT","Promise","resolve","window","script","document","VALIDATOR_JS","skipSet","Set","preprocessingModules","module","ViewerCapability","ViewerViewportType","ViewerVisibilityState","IFRAME_FEATURE_POLICY","IFRAME_SANDBOX","IFRAME_STYLES","VIEWER_PARAMETERS","prerenderSize","visibilityState","paddingTop","history","p2r","horizontalScrolling","storage","development","log","csi","cap","DEFAULT_RENDERING_MODULES","[object Object]","win","origin","target","this","eventType","handler","event","data","opt_token","channel","MessageChannel","err","console","pollMessage","app","name","port","listener","clearInterval","intervalRef","messaging","Messaging","source","WindowPortEmulator","opt_isWebview","opt_verifyToken","messageName","requestHandler","REQUEST","RESPONSE","messageData","awaitResponse","promise","undefined","reject","requestId","requestid","type","rsvp","reason","errString","error","finalMessage","JSON","Error","pending","state","opt_data","stateStr","dataStr","String","ErrorType","ErrorExpectancy","IframeHeightImpl","frameContainer","this.documentHeightHandler","_this","ErrorHandlerImpl","this.errorHandler","_this2","_context","modules","load","impl","module$1","load$1","parent","this.messageHandler","this.documentLoaded","viewerConfig.DEFAULT_RENDERING_MODULES","options","_this$iframe2","btoa","iframeOptions","width","height","featurePolicy","viewerConfig.IFRAME_FEATURE_POLICY","sandbox","styles","viewerConfig.IFRAME_STYLES","iframe","onRenderSuccess","onRenderError","_this3","setTimeout","_this4","renderingModules","viewerConfig.IFRAME_SANDBOX","relayPageURL","d","url","messagingToken","viewerConfig.VIEWER_PARAMETERS","bytes","Uint8Array","bytesStr","URL","module$2","process"],"mappings":"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"}